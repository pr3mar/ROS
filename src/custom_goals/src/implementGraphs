#!/usr/bin/env python
import dynamic_reconfigure.client
import roslib, sys
import rospy
import actionlib
import random
import math
from graph.graph import Graph
from std_msgs.msg import String
from tf.transformations import quaternion_from_euler

# from sensor_msgs.msg import image_encodings # do I need this?
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal, MoveBaseActionGoal
from actionlib_msgs.msg import GoalStatusArray
from geometry_msgs.msg import *
from actionlib_msgs.msg import GoalStatus

colorMap = {"red":0, "yellow":1, "blue":2, "green":3}
goals = []
globGoals = []
graph = None
alib = None
currentLocation = None
setGoal = False
poses_to_remove = {"3-4": [(3, 4), False], "14-16": [(14, 16), False]}
reconf = None
canceled = False
reached = None

# maybe not usefull at all, just for exploring
def sendAllGoals():
	if(alib == None):
		rospy.loginfo("WTF? Actionlib is None, sendAllGoals()")
		return
	i = 0
	for node in graph.nodes:
		rospy.loginfo("Sending goal: " + str(i))
		goal = MoveBaseGoal()
		stamp = rospy.Time.now()
		goal = node.goal
		goal.target_pose.header.stamp = stamp
		print goal
		alib.send_goal(goal)
		result = alib.wait_for_result(rospy.Duration(90.0))
		state = alib.get_state()
		print "result = ", result, ", state = ", state
		#if result and state == GoalStatus.SUCCEEDED:
		#	result = True
		#else:
		#	rospy.loginfo("FAILED TO REACH GOAL")
		#	alib.cancel_goal()
		i += 1

# cancel all goals if message is true
def cancel(msg):
	global setGoal, globGoals#, canceled
	print "canceling a goal: ", msg
	print "before canceling", globGoals
	if(msg.data == "true"):
		print "canceling for real!!!"
		alib.cancel_goal()
		setGoal = False
		globGoals = []
		#canceled = True
	print "after canceling", globGoals

# just a wrapper:
# send goals to the robot, given a list of node ids
def send(goals):
	global setGoal, globGoals, canceled, reached, alib
	# globGoals = goals
	if setGoal:
		rospy.loginfo("CANCELING THE PREVIOUSLY SENDT GOALS")
		alib.cancel_goal()
	if(alib == None):
		rospy.loginfo("WTF? Actionlib is None, send(goals)")
		return
	rospy.loginfo("sending " + str(goals))
	# print "entered send(goals)"
	setGoal = True
	state = -1
	rots = [(0, 0, 90 * 3.1415/180), (0, 0, 90 * 3.1415/180), (0, 0, 180 * 3.1415/180), (0, 0, 270 * 3.1415/180), (0, 0, 0)]
	print goals
	for nodeID in goals:
		#print "canceled?", canceled
		# if canceled:
			# break
		node = graph.getNodeByID(nodeID)
		rospy.loginfo("Sending graph goal: " + str(nodeID))
		goal = MoveBaseGoal()
		stamp = rospy.Time.now()
		goal = node.goal
		goal.target_pose.header.stamp = stamp
		# print goal
		alib.send_goal(goal)
		result = alib.wait_for_result(rospy.Duration(90.0))
		state = alib.get_state()
		print "result = ", result, ", state = ", state
		if state != GoalStatus.SUCCEEDED:#(state == GoalStatus.PREEMPTED or state == GoalStatus.PREEMPTING or state == GoalStatus.RECALLING or state == GoalStatus.PENDING):
			rospy.loginfo("[main] CANCELED THE FUCKING GOALS")
			goals = []
			return
		for i in range(len(rots)):
			tmp = quaternion_from_euler(rots[i][0], rots[i][1], rots[i][2])
			# print tmp
			goal.target_pose.pose.orientation.x = tmp[0]
			goal.target_pose.pose.orientation.y = tmp[1]
			goal.target_pose.pose.orientation.z = tmp[2]
			goal.target_pose.pose.orientation.w = tmp[3]
			alib.send_goal(goal)
			result = alib.wait_for_result(rospy.Duration(90.0))
			state = alib.get_state()
			print "rotation: result = ", result, ", state = ", state
			if state != GoalStatus.SUCCEEDED:# and (state == GoalStatus.PREEMPTED or state == GoalStatus.PREEMPTING or state == GoalStatus.RECALLING or state == GoalStatus.PENDING):
				rospy.loginfo("[rot] CANCELED THE FUCKING GOALS")
				goals = []
				return

	# if not canceled:
		# reached.publish("true")
	# canceled = False
	setGoal = False

#localize by current position of rooomba
def localizeRoomba(poseWithCov): # get data from /amcl_pose
	global setGoal, currentLocation
	nearest_node = graph.localize(poseWithCov.pose.pose)
	currentLocation = nearest_node[0]
	#print "location = ", nearest_node[0], nearest_node[1]
	
	# this need to be reset somewhere else
	if not setGoal and False: # dead code at the moment, just to test
		rospy.loginfo("GENERATING NEW PATH!!!")
		pose = graph.nodes[4].goal.target_pose.pose
	 	p2 = graph.localize(pose)
		
	 	path = graph.Astar(nearest_node[0], p2[0])
	 	# print path
	 	send(path)
	# # TODO: how to return the point? Concept.

# search on street X
def searchStreets(street):
	global currentLocation, colorMap, canceled
	# canceled = False
	print "going to explore a street"
	if street.data in colorMap:
		streets = graph.getByColorSorted(currentLocation.goal.target_pose.pose, colorMap[street.data])
		#print streets
		path = graph.Astar(currentLocation, streets[0][0])
		path = path + [x[0].id for x in streets[1:]]
		print path#, "canceled", canceled
		send(path)
	
# go to a specific position (where a face is located)
def gotoPose(pose):
	global currentLocation, canceled
	# canceled = False
	print "going to a predefined position"
	nearest_goal_position = graph.localize(pose)
	goal_position = nearest_goal_position[0]
	path = graph.Astar(currentLocation, goal_position)[1:]
	print path#, "canceled", canceled
	send(path)

# recognized sign (oneway) is situated in pose
# find the nearest node and remove the edge
# only works if the nearest nodes are from the predefined global poses_to_remove
def removeEdges(pose):
	global poses_to_remove
	nearest_node = graph.localize(pose)
	for edge in poses_to_remove:
		if not nearest_node[1]:
			el = poses_to_remove[edge]
			if(nearest_node[0] == edge[0][0] or nearest_node[0] == edge[0][1]):
				print graph.removeEdge(edge[0])
				edge[1] = True
def honk(msg):
	pass

def slow(msg):
	global reconf
	if msg.data == "true":
		reconf.update_configuration({"max_vel_x": 0.05})
		reconf.update_configuration({"max_rot_vel": 0.5})
		# reconf.update_configuration({"acc_lim_v": 0.35})
		#rospy.Timer(rospy.Duration(10), resetSpeed)

def stop(msg):
	global reconf
	if msg.data == "true":
		reconf.update_configuration({"speed_lim_v": 0.0})
		reconf.update_configuration({"max_rot_vel": 0.0})
		#rospy.Timer(rospy.Duration(10), resetSpeed)

def resetSpeed(arg):
	global reconf
	reconf.update_configuration({"max_vel_x": 0.4})
	reconf.update_configuration({"max_rot_vel": 1.5})
	# reconf.update_configuration({"acc_lim_v": 0.75})
	#return True

if __name__ == '__main__':
	try:
		test = False
		doROS = True
		if test:
			# solely for testing purposes:
			goals = []
			#ids: 0  1  2  3  4  5
			xx = [0,-2, 0, 2, 1,-1]
			yy = [0, 1, 1, 1, 2, 4]
			colors = [0, 1, 2, 3, 4, 5]
			for i in range(0,6):
				goal = MoveBaseGoal()
				goal.target_pose.pose.position.x = xx[i]#random.randrange(0, 20)
				goal.target_pose.pose.position.y = yy[i]#random.randrange(0, 20)
				goals.append(goal)
			# edges = [(0, 1), (0, 2), (0, 4), (1, 5), (2, 3), (3,6), (4, 5), (5, 6), (5, 7), (6, 8), (7, 9), (8,9)]
			edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 5), (2, 4), (3, 4), (4, 5)]
			graph = Graph(goals, edges)
			# graph.printGraph()
			pose = Pose()
			pose.position.x = xx[0]
			pose.position.y = yy[0]
			p1 = graph.localize(pose)
			pose.position.x = xx[5]
			pose.position.y = yy[5]
			p2 = graph.localize(pose)
			print "removed = ", graph.removeEdge((2,4))
			# print "nearest to: ", p1[0], "distance = ", p1[1]
			# print "nearest to: ", p2[0], "distance = ", p2[1]
			print graph.Astar(p1[0], p2[0])
			graph.defineEdges([(2,4)])
			print graph.Astar(p1[0], p2[0])
			graph.printGraph()
		else: # TODO: make it work with ROS!!!!
			# init graph 
			x_coords = [ \
				#red street
				8.32, 7.61, 7.47,\

				# yellow street
				7.15, 7.05, 6.99,\

				#blue street
				6.15, 5.17, 4.13, 3.04, 2.10, \

				#green street
				2.19, 2.11, 3.09, 4.10, 4.04, 5.34, 6.22
			]
			y_coords = [ \
				#red street
				-2.2, -2.29, -1.41,\

				# yellow street
				-0.07, 0.70, 1.5,\

				#blue street
				1.36, 1.18, 0.99, 0.99, 0.97, \

				#green street
				0.26, -0.63, -0.59, -0.43, 0.32, -0.17, -0.11
			]
			colors = [ \
				#red street
				0, 0, 0,\

				# yellow street
				1, 1, 1,\

				#blue street
				2, 2, 2, 2, 2, \

				#green street
				3, 3, 3, 3, 3, 3, 3
			]
			goals = []
			for i in range(len(x_coords)):
				goal = MoveBaseGoal()
				goal.target_pose.header.frame_id = "/map"
				goal.target_pose.pose.position.x = x_coords[i]#random.randrange(0, 20)
				goal.target_pose.pose.position.y = y_coords[i]#random.randrange(0, 20)
				goal.target_pose.pose.orientation.w = 1 #random.randrange(0, 20)
				goals.append(goal)
			edges = [
				(0, 1),
				(1, 0), (1, 2),
				(2, 1), (2, 3),
				(3, 2), (3, 4), (3, 17),
				(4, 3), (4, 5),
				(5, 4), (5, 6),
				(6, 5), (6, 7),
				(7, 6), (7, 8),
				(8, 7), (8, 9), (8, 15),
				(9, 8), (9, 10),
				(10, 9), (10, 11),
				(11, 10), (11, 12),
				(12, 11), (12, 13),
				(13, 12), (13, 14),
				(14, 13), (14, 15), (14, 16),
				(15, 8), (15, 14),
				(16, 14), (16, 17),
				(17, 3), (17, 16)
			]
			graph = Graph(goals, edges, colors)
			# graph.printGraph()
			#print "removed = ", graph.removeEdge((14,16))
			#print "removed = ", graph.removeEdge((3, 4))
			# graph.printGraph()
			# print rospy.get_name()
			# pose = graph.nodes[0].goal.target_pose.pose
			# p1 = graph.localize(pose)
			# pose = graph.nodes[4].goal.target_pose.pose
			# p2 = graph.localize(pose)
			
			# path = graph.Astar(p1[0], p2[0])
			#   # get all nodes by color
			# print p2[0], p2[1]
			# for color in colorMap:
			# 	print color,
			# 	for x in graph.getByColorSorted(pose, colorMap[color]):
			# 		print "(" + str(x[0]) + ", " + str(x[1]) + ")",
			# 	print

			if doROS:
				rospy.init_node('graph_send_goals')
				# init the actionlib server to send goals (works only locally)
				alib = actionlib.SimpleActionClient("move_base", MoveBaseAction)
				reconf = dynamic_reconfigure.client.Client("/move_base/DWAPlannerROS")
				reached = rospy.Publisher("/goal_reached", String, queue_size=100)
				reconf.update_configuration({"max_vel_x": 0.4})
				reconf.update_configuration({"max_rot_vel": 1.5})
				reconf.update_configuration({"xy_goal_tolerance": 0.25})
				reconf.update_configuration({"yaw_goal_tolerance": 0.5})
				# reconf.update_configuration({"acc_lim_v": 0.75})
				rospy.loginfo("Waiting for actionlib server")
				alib.wait_for_server(rospy.Duration(5.0))
				rospy.loginfo("Actionlib server started.")
				rospy.Subscriber("/amcl_pose", PoseWithCovarianceStamped, localizeRoomba)
				rospy.Subscriber("/cancel", String, cancel)
				rospy.Subscriber("/search/street", String, searchStreets)
				rospy.Subscriber("/goto", Pose, gotoPose)
				rospy.Subscriber("/sign/slow", String, slow)
				rospy.Subscriber("/sign/stop", String, stop)
				rospy.Subscriber("/sign/honk", String, honk)
				rospy.Subscriber("/sign/oneway", Pose, removeEdges)
				#sendAllGoals() # just to explore the map
			
				rospy.spin()

	except rospy.ROSInterruptException:
		pass

# list of dots on the map:
# red street:
#   x    y
# 8.32, -2.2
# 7.61, -2.29
# 7.47, -1.41
#
# yellow street:
#  x     y
# 7.15, -0.07
# 7.05, 0.70
# 6.99, 1.5
#
# blue street:
#   x    y
# 6.15, 1.36
# 5.17, 1.18
# 4.13, 0.99
# 3.04, 0.99
# 2.10, 0.97
#
# green street:
#   x    y
# 2.19, 0.26
# 2.11, -0.63
# 3.09, -0.59
# 4.10, -0.43
# 4.04, 0.32
# 5.34, -0.17
# 6.22, -0.11

